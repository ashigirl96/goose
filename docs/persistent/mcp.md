# Model Context Protocol (MCP) の概念

## サンプリング

サンプリングは、サーバーがクライアントを通じてLLM（大規模言語モデル）の補完をリクエストできるようにする強力なMCP機能です。これにより、セキュリティとプライバシーを維持しながら、高度なエージェント的な振る舞いが可能になります。

### サンプリングの仕組み

サンプリングのフローは以下のステップに従います：

1. サーバーがクライアントに `sampling/createMessage` リクエストを送信する
2. クライアントがリクエストを確認し、必要に応じて修正する
3. クライアントがLLMからサンプリング（補完）を行う
4. クライアントが補完結果を確認する
5. クライアントが結果をサーバーに返す

この人間参加型の設計により、ユーザーはLLMが見る内容と生成する内容を常にコントロールできます。

### サンプリングの主なメリット

サンプリングには以下のような重要なメリットがあります：

1. **クライアント・サーバー関係の逆転**：
   従来はクライアントがサーバーにリクエストを送信しますが、サンプリングでは逆にサーバーがクライアント経由でLLMの能力を利用できます。これにより、サーバー側のプログラムがAIの推論能力を活用できるようになります。

2. **プライバシーとセキュリティの向上**：
   クライアントがモデルの選択、ホスティング、プライバシー、コスト管理を完全にコントロールできます。機密データを外部に送信することなく、ローカル環境でLLMの能力を活用できます。

3. **エージェント的な振る舞いの実現**：
   サーバーは必要なときにLLMに質問や分析をリクエストできるため、より複雑なワークフローや自律的な処理が可能になります。

4. **柔軟なモデル選択と設定**：
   サーバーは特定の推論パラメータをリクエストできますが、最終的な決定権はクライアント側にあります。これにより、不適切なリクエストの拒否やリソース使用の制限が可能です。

5. **信頼性と安全性の確保**：
   未知のサーバーと対話する場合でも、クライアントは安全性を確保しながらインテリジェントな機能へのアクセスを提供できます。

### サンプリングリクエストのタイミング

サーバーがクライアントにサンプリングリクエストを送る一般的なタイミングは以下の通りです：

1. **データ分析が必要なとき**：
   サーバーが処理しているデータの解釈や分析が必要な場合（例：ファイルの内容を理解する、テキストを要約する）

2. **決定が必要なとき**：
   サーバーが次のステップを決定するためにLLMの推論能力が必要な場合（例：ユーザーの意図を解釈する、選択肢から最適なものを選ぶ）

3. **コンテンツ生成が必要なとき**：
   データに基づいて新しいコンテンツを生成する必要がある場合（例：レポート作成、コード生成）

#### サンプリングリクエストの具体例

各種MCPサーバーがサンプリングを使用する具体的なケース：

- **ファイルシステムサーバー**：ファイルの内容を理解・要約するとき
- **データベースサーバー**：クエリ結果を分析・解釈するとき
- **GitHubサーバー**：コードレビューやPRの要約を生成するとき
- **ブラウザサーバー**：ウェブページの内容を分析するとき

リクエストフローの例（ファイルシステムサーバーの場合）：
1. ユーザーがクライアント（Claude Desktopなど）でファイルシステムに関する質問をする
2. クライアントがファイルシステムサーバーにリクエストを転送
3. サーバーがファイルシステムから関連情報を取得
4. **サーバーがサンプリングリクエストをクライアントに送る**（このタイミングでLLMの能力が必要）
5. クライアントがLLMを使用して結果を生成し、サーバーに返す
6. サーバーがこの結果を使って最終的な応答をクライアントに返す
7. クライアントがユーザーに結果を表示

### メッセージフォーマット

サンプリングリクエストは標準化されたメッセージフォーマットを使用します：

#### リクエストパラメータ

- **messages**: 会話の履歴を含む配列。各メッセージには以下が含まれます：
  - `role`: "user"または"assistant"
  - `content`: メッセージの内容（テキストまたは画像）

- **modelPreferences**: サーバーがモデル選択の好みを指定できるオブジェクト：
  - `hints`: クライアントがモデル選択に使用できるモデル名の提案の配列
  - 優先度の値（0-1に正規化）：
    - `costPriority`: コスト最小化の重要度
    - `speedPriority`: 低レイテンシー応答の重要度
    - `intelligencePriority`: 高度なモデル機能の重要度

- **systemPrompt**: サーバーが特定のシステムプロンプトをリクエストできるオプションフィールド

- **includeContext**: 含めるMCPコンテキストを指定：
  - `"none"`: 追加コンテキストなし
  - `"thisServer"`: リクエスト元サーバーからのコンテキストを含める
  - `"allServers"`: 接続されているすべてのMCPサーバーからのコンテキストを含める

クライアントは、実際に含まれるコンテキストを制御します。

#### サンプリングパラメータ

LLMサンプリングを微調整するためのパラメータ：

- `temperature`: ランダム性を制御（0.0〜1.0）
- `maxTokens`: 生成する最大トークン数
- `stopSequences`: 生成を停止するシーケンスの配列
- `metadata`: プロバイダー固有の追加パラメータ

### リクエスト例

クライアントからのサンプリングリクエストの例：

```json
{
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "現在のディレクトリにはどのようなファイルがありますか？"
        }
      }
    ],
    "systemPrompt": "あなたは役立つファイルシステムアシスタントです。",
    "includeContext": "thisServer",
    "maxTokens": 100
  }
}
```

### ベストプラクティス

サンプリングを実装する際のベストプラクティス：

- 明確で構造化されたプロンプトを常に提供する
- テキストと画像の両方のコンテンツを適切に処理する
- 合理的なトークン制限を設定する
- `includeContext` を通じて関連するコンテキストを含める
- 使用前にレスポンスを検証する
- エラーを適切に処理する
- サンプリングリクエストのレート制限を検討する
- 期待されるサンプリング動作を文書化する
- さまざまなモデルパラメータでテストする
- サンプリングコストを監視する

### 人間参加型のコントロール

サンプリングは人間の監視を念頭に設計されています：

**プロンプトに対して**:
- クライアントはユーザーに提案されたプロンプトを表示する必要がある
- ユーザーはプロンプトを修正または拒否できる必要がある
- システムプロンプトはフィルタリングまたは修正される可能性がある
- コンテキストの包含はクライアントによって制御される

**補完に対して**:
- クライアントはユーザーに補完を表示する必要がある
- ユーザーは補完を修正または拒否できる必要がある
- クライアントは補完をフィルタリングまたは修正できる
- ユーザーはどのモデルが使用されるかを制御する

### セキュリティの考慮事項

サンプリングを実装する際のセキュリティ考慮事項：

- すべてのメッセージ内容を検証する
- 機密情報をサニタイズする
- 適切なレート制限を実装する
- サンプリングの使用状況を監視する
- 転送中のデータを暗号化する
- ユーザーデータのプライバシーを処理する
- サンプリングリクエストを監査する
- コスト露出を制御する
- タイムアウトを実装する
- モデルエラーを適切に処理する

### 一般的なパターン

サンプリングにより可能になるエージェント的なワークフロー：

- リソースの読み取りと分析
- コンテキストに基づく意思決定
- 構造化データの生成
- 複数ステップのタスクの処理
- インタラクティブな支援の提供

### 制限事項

以下の制限事項に注意する必要があります：

- サンプリングはクライアント機能に依存する
- ユーザーがサンプリング動作を制御する
- コンテキストサイズには制限がある
- レート制限が適用される場合がある
- コストを考慮する必要がある
- モデルの可用性は異なる
- 応答時間は異なる
- すべてのコンテンツタイプがサポートされているわけではない

## トランスポート

トランスポートはModel Context Protocol（MCP）におけるクライアントとサーバー間の通信基盤を提供します。トランスポートは、メッセージの送受信の基礎となるメカニズムを処理します。

### メッセージフォーマット

MCPは、ワイヤフォーマットとして[JSON-RPC](https://www.jsonrpc.org/) 2.0を使用しています。トランスポート層はMCPプロトコルメッセージをJSON-RPC形式に変換して送信し、受信したJSON-RPCメッセージをMCPプロトコルメッセージに戻す役割を担います。

JSON-RPCメッセージには、以下の3種類があります：
- リクエスト
- レスポンス
- 通知

### 組み込みトランスポートタイプ

MCPには、2つの標準トランスポート実装が含まれています：

#### 標準入出力（stdio）

stdioトランスポートは、標準入力および出力ストリームを通じた通信を可能にします。これは、ローカル統合やコマンドラインツールに特に有用です。

以下の場合にstdioを使用します：
- コマンドラインツールの構築
- ローカル統合の実装
- シンプルなプロセス間通信
- シェルスクリプトとの連携

#### サーバー送信イベント（SSE）

SSEトランスポートは、サーバーからクライアントへのストリーミングを可能にし、クライアントからサーバーへの通信にはHTTP POSTリクエストを使用します。

以下の場合にSSEを使用します：
- サーバーからクライアントへのストリーミングのみが必要な場合
- 制限されたネットワークで作業する場合
- シンプルな更新を実装する場合

##### セキュリティ警告：DNSリバインディング攻撃

SSEトランスポートは、適切に保護されていないとDNSリバインディング攻撃に対して脆弱になる可能性があります。これを防ぐために：

- 受信SSE接続のOriginヘッダーを常に検証し、期待されるソースからのものであることを確認する
- ローカルで実行する場合、サーバーをすべてのネットワークインターフェース（0.0.0.0）にバインドせず、代わりにlocalhostのみ（127.0.0.1）にバインドする
- すべてのSSE接続に適切な認証を実装する

これらの保護がなければ、攻撃者はDNSリバインディングを使用してリモートウェブサイトからローカルMCPサーバーと対話する可能性があります。

### カスタムトランスポート

MCPは、特定のニーズに合わせたカスタムトランスポートの実装を容易にします。すべてのトランスポート実装は、Transportインターフェースに準拠する必要があります。

カスタムトランスポートは以下の目的で実装できます：
- カスタムネットワークプロトコル
- 特殊な通信チャネル
- 既存システムとの統合
- パフォーマンス最適化

### エラー処理

トランスポート実装では、以下のようなさまざまなエラーシナリオを処理する必要があります：
- 接続エラー
- メッセージ解析エラー
- プロトコルエラー
- ネットワークタイムアウト
- リソースのクリーンアップ

### ベストプラクティス

MCPトランスポートを実装または使用する際のベストプラクティス：

- 接続ライフサイクルを適切に処理する
- 適切なエラー処理を実装する
- 接続終了時にリソースをクリーンアップする
- 適切なタイムアウトを使用する
- メッセージを送信前に検証する
- デバッグ用にトランスポートイベントをログに記録する
- 適切な場合は再接続ロジックを実装する
- メッセージキューの背圧を処理する
- 接続の健全性を監視する
- 適切なセキュリティ対策を実装する

### セキュリティの考慮事項

トランスポートを実装する際のセキュリティ考慮事項：

#### 認証と認可
- 適切な認証メカニズムを実装する
- クライアント資格情報を検証する
- 安全なトークン処理を使用する
- 認可チェックを実装する

#### データセキュリティ
- ネットワークトランスポートにTLSを使用する
- 機密データを暗号化する
- メッセージの整合性を検証する
- メッセージサイズ制限を実装する
- 入力データをサニタイズする

#### ネットワークセキュリティ
- レート制限を実装する
- 適切なタイムアウトを使用する
- サービス拒否シナリオを処理する
- 異常なパターンを監視する
- 適切なファイアウォールルールを実装する
- SSEトランスポートの場合、DNSリバインディング攻撃を防ぐためにOriginヘッダーを検証する
- ローカルSSEサーバーの場合、すべてのインターフェース（0.0.0.0）ではなくlocalhostのみ（127.0.0.1）にバインドする

### トランスポートのデバッグ

トランスポートの問題をデバッグするためのヒント：
- デバッグログを有効にする
- メッセージフローを監視する
- 接続状態を確認する
- メッセージフォーマットを検証する
- エラーシナリオをテストする
- ネットワーク分析ツールを使用する
- ヘルスチェックを実装する
- リソース使用状況を監視する
- エッジケースをテストする
- 適切なエラー追跡を使用する
