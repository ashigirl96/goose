"use strict";(self.webpackChunkgoose=self.webpackChunkgoose||[]).push([[2657],{2214:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"goose-architecture/mcp-architecture","title":"MCP Architecture & Tool Selection","description":"This document describes the Message Control Protocol (MCP) architecture in Goose and how the system processes user instructions to determine which tools to invoke.","source":"@site/docs/goose-architecture/mcp-architecture.md","sourceDirName":"goose-architecture","slug":"/goose-architecture/mcp-architecture","permalink":"/goose/docs/goose-architecture/mcp-architecture","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Extensions Design","permalink":"/goose/docs/goose-architecture/extensions-design"},"next":{"title":"MCP\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u3068\u30c4\u30fc\u30eb\u9078\u629e\u30d7\u30ed\u30bb\u30b9","permalink":"/goose/docs/goose-architecture/mcp-architecture-ja"}}');var o=s(74848),t=s(28453);const l={sidebar_position:3},r="MCP Architecture & Tool Selection",c={},a=[{value:"Overview",id:"overview",level:2},{value:"MCP Communication Flow",id:"mcp-communication-flow",level:2},{value:"Tool Selection Process",id:"tool-selection-process",level:2},{value:"Stage 1: LLM-Based Tool Selection",id:"stage-1-llm-based-tool-selection",level:3},{value:"Stage 2: MCP Client/Tool Resolution",id:"stage-2-mcp-clienttool-resolution",level:3},{value:"MCP Server Implementations",id:"mcp-server-implementations",level:2},{value:"Example Flow",id:"example-flow",level:2},{value:"Benefits of MCP Architecture",id:"benefits-of-mcp-architecture",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"mcp-architecture--tool-selection",children:"MCP Architecture & Tool Selection"})}),"\n",(0,o.jsx)(n.p,{children:"This document describes the Message Control Protocol (MCP) architecture in Goose and how the system processes user instructions to determine which tools to invoke."}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"The Message Control Protocol (MCP) is a fundamental component of Goose that enables communication between the main application and various extensions. MCP provides a standardized way to:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Define the capabilities of extensions through tools"}),"\n",(0,o.jsx)(n.li,{children:"Process user instructions to select the appropriate extension and tool"}),"\n",(0,o.jsx)(n.li,{children:"Execute tool calls and return results to the conversation flow"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"mcp-communication-flow",children:"MCP Communication Flow"}),"\n",(0,o.jsx)(n.p,{children:"The MCP architecture follows a client-server model:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"MCP Servers"}),": Each extension runs as an MCP server, providing tools and capabilities"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"MCP Clients"}),": The main Goose application maintains client connections to each extension"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"JSON-RPC Protocol"}),": Communication between clients and servers uses JSON-RPC messages"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"User Input \u2192 Goose Core \u2192 LLM \u2192 Tool Selection \u2192 MCP Client \u2192 MCP Server (Extension) \u2192 Tool Execution\n"})}),"\n",(0,o.jsx)(n.h2,{id:"tool-selection-process",children:"Tool Selection Process"}),"\n",(0,o.jsx)(n.p,{children:"When a user gives an instruction to Goose, the system follows a two-stage process to determine which extension and tool to use:"}),"\n",(0,o.jsx)(n.h3,{id:"stage-1-llm-based-tool-selection",children:"Stage 1: LLM-Based Tool Selection"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Tool Information Collection"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Goose collects all available tools from all active extensions via ",(0,o.jsx)(n.code,{children:"capabilities.get_prefixed_tools()"})]}),"\n",(0,o.jsxs)(n.li,{children:["Each tool is prefixed with its extension name (e.g., ",(0,o.jsx)(n.code,{children:"developer__shell"}),")"]}),"\n",(0,o.jsx)(n.li,{children:"Tools include name, description, and parameter schema"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"LLM Processing"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The user's instruction, system prompt, and tool information are passed to the LLM via ",(0,o.jsx)(n.code,{children:"provider().complete(...)"})]}),"\n",(0,o.jsx)(n.li,{children:"The LLM analyzes the instruction and determines the most appropriate tool to use"}),"\n",(0,o.jsxs)(n.li,{children:["The provider-specific format converters (e.g., ",(0,o.jsx)(n.code,{children:"google.rs"}),", ",(0,o.jsx)(n.code,{children:"openai.rs"}),") handle the API-specific formats"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Response Parsing"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The LLM's response is processed by provider-specific parsers (e.g., ",(0,o.jsx)(n.code,{children:"response_to_message()"}),")"]}),"\n",(0,o.jsx)(n.li,{children:"If the LLM decides to use a tool, it includes a tool call in its response"}),"\n",(0,o.jsxs)(n.li,{children:["This is converted to a ",(0,o.jsx)(n.code,{children:"MessageContent::ToolRequest"})," with the tool name and arguments"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Example code for converting an LLM's tool call (from Google AI):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'if let Some(function_call) = part.get("functionCall") {\n    let id = generate_random_id();\n    let name = function_call["name"].as_str().unwrap_or_default().to_string();\n    \n    if !is_valid_function_name(&name) {\n        // Handle invalid function name\n    } else {\n        if let Some(params) = function_call.get("args") {\n            content.push(MessageContent::tool_request(\n                id,\n                Ok(ToolCall::new(&name, params.clone())),\n            ));\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"stage-2-mcp-clienttool-resolution",children:"Stage 2: MCP Client/Tool Resolution"}),"\n",(0,o.jsx)(n.p,{children:"Once the LLM identifies a tool to use, Goose must determine which extension handles that tool:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Extension Identification"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"dispatch_tool_call"})," method in ",(0,o.jsx)(n.code,{children:"capabilities.rs"})," processes the tool call"]}),"\n",(0,o.jsx)(n.li,{children:"It uses the tool name prefix to identify which extension should handle the call"}),"\n",(0,o.jsxs)(n.li,{children:["The method ",(0,o.jsx)(n.code,{children:"get_client_for_tool"})," searches for a matching MCP client:"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"fn get_client_for_tool(&self, prefixed_name: &str) -> Option<(&str, McpClientBox)> {\n    self.clients\n        .iter()\n        .find(|(key, _)| prefixed_name.starts_with(*key))\n        .map(|(name, client)| (name.as_str(), Arc::clone(client)))\n}\n"})}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Tool Name Extraction"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Once the extension is identified, the extension-specific tool name is extracted:"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'let tool_name = tool_call\n    .name\n    .strip_prefix(client_name)\n    .and_then(|s| s.strip_prefix("__"))\n    .ok_or_else(|| ToolError::NotFound(tool_call.name.clone()))?;\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Tool Execution"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The identified MCP client is used to call the specific tool"}),"\n",(0,o.jsx)(n.li,{children:"Parameters from the LLM are passed to the tool"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"let client_guard = client.lock().await;\nclient_guard\n    .call_tool(tool_name, tool_call.clone().arguments)\n    .await\n    .map(|result| result.content)\n    .map_err(|e| ToolError::ExecutionError(e.to_string()))\n"})}),"\n",(0,o.jsx)(n.h2,{id:"mcp-server-implementations",children:"MCP Server Implementations"}),"\n",(0,o.jsx)(n.p,{children:"MCP servers can be implemented in three ways:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Built-in"}),": Extensions embedded within the Goose binary"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Run as separate processes, but use the same executable"}),"\n",(0,o.jsx)(n.li,{children:"Communication via standard I/O"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Stdio"}),": External extensions communicating via standard I/O"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Can be implemented in any language"}),"\n",(0,o.jsx)(n.li,{children:"Run as child processes"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Server-Sent Events (SSE)"}),": RESTful HTTP endpoints"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Remote extensions that can run on different machines"}),"\n",(0,o.jsx)(n.li,{children:"Communicate via HTTP streaming"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"example-flow",children:"Example Flow"}),"\n",(0,o.jsx)(n.p,{children:"Here's an example of how the entire process works when a user asks Goose to list files:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:'User types: "List all files in the current directory"'}),"\n",(0,o.jsxs)(n.li,{children:["LLM analyzes this request and decides to use the ",(0,o.jsx)(n.code,{children:"developer__shell"})," tool"]}),"\n",(0,o.jsxs)(n.li,{children:["LLM response includes a tool call: ",(0,o.jsx)(n.code,{children:'{name: "developer__shell", args: {command: "ls -la"}}'})]}),"\n",(0,o.jsx)(n.li,{children:"Goose processes this response and extracts the tool request"}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"dispatch_tool_call"})," identifies:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Extension: ",(0,o.jsx)(n.code,{children:"developer"})]}),"\n",(0,o.jsxs)(n.li,{children:["Tool: ",(0,o.jsx)(n.code,{children:"shell"})]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"developer"})," MCP client is used to call the ",(0,o.jsx)(n.code,{children:"shell"})," tool with ",(0,o.jsx)(n.code,{children:"ls -la"})," argument"]}),"\n",(0,o.jsx)(n.li,{children:"The shell tool executes the command and returns the result"}),"\n",(0,o.jsxs)(n.li,{children:["Results are added to the conversation as a ",(0,o.jsx)(n.code,{children:"ToolResponse"})]}),"\n",(0,o.jsx)(n.li,{children:"Conversation continues with the tool results included"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"benefits-of-mcp-architecture",children:"Benefits of MCP Architecture"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Modularity"}),": Extensions can be developed and deployed independently"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Flexibility"}),": Extensions can be implemented in any language"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Security"}),": Extensions run as separate processes with controlled communication"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Consistency"}),": Standardized protocol for all tool interactions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Discoverability"}),": LLM can discover and use tools based on descriptions"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This architecture allows Goose to dynamically adapt to user requests while maintaining a clean separation between the core system and its extensions."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>r});var i=s(96540);const o={},t=i.createContext(o);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);